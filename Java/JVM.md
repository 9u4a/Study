**JVM에 대하여 얘기하기 전에 JDK에 대해 알아보자.**

![Untitled](https://github.com/9u4a/Study/assets/81855010/6628981c-4a33-488b-a65e-88bd8b93df5f)



### JDK (Java Development Kit)

자바 개발에서 가장 널리 사용되는 SDK로 컴파일러, JRE, javac 등 개발도구를 포함한다.

**JDK의 bin에 포함된 주요 개발 도구**

- **javac** : 자바소스를 바이트코드로 변환하는 컴파일러
- **java** : JVM을 작동시켜 자바프로그램 실행하는 인터프리터
- **javadoc** : 자바소스로부터 HTML 형식의 API doc 생성
- **jar** : 자바 클래스들을 압축한 자바 아카이브 파일 생성 관리(.jar)
- **jlink** : 응용프로그램에 맞춘 맞춤형 JRE 제공
- **jdb** : 실행 중 오류를 찾는 데 사용하는 디버거
- **javap** : 클래스 파일의 바이트코드를 소스와 함께 보여주는 디어셈블러

### JRE (Java Runtime Environment)

자바 실행 환경으로 JVM과 자바 클래스 라이브러리로 구성되어 자바 애플리케이션의 실행을 지원

(운영 체제에 종속)

### JVM(Java Virtual Machine)

자바 바이트코드를 해석하고 실행하는 가상 기계로 JVM은 자바 애플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행한다. 플랫폼 독립성 제공

## 자바코드 수행 과정

![Untitled](https://github.com/9u4a/Study/assets/81855010/f5a62e89-7049-4ea8-a609-4e1e2f7d0549)

1. 컴파일러가 소스코드를 바이트코드로 컴파일
2. 클래스 로더가 런타임 데이터 영역에 로딩
3. 실행 엔진이 자바 바이트코드 실행

## 클래스 로더 (Class Loader)

![Untitled](https://github.com/9u4a/Study/assets/81855010/494184b0-50e5-4146-bc18-22126e42db11)


자바는 컴파일타임이 아니라 런타임에 클래스를 처음으로 참조할 때 해당 클래스를 로드하고 링크하는 특징이 있다.  클래스 로더는 클래스 파일을 동적으로 로드하는 컴포넌트다.

### 클래스 로더의 특징

- **계층 구조** : 클래스 로더끼리 부모-자식 관계를 이루어 자식 클래스 로더가 부모 클래스 로더가 로드한 클래스에 접근 가능. → 부모 클래스로더는 자식 클래스 로더에서 클래스 로드 불가(책임 분리)
- **위임 모델** : 계층 구조를 바탕으로 클래스를 로드할 때 먼저 상위 클래스 로더를 확인하고 클래스를 찾지 못하면 그 후에 요청을 받은 클래스 로더가 클래스를 로드한다.
- **언로드 불가** : 클래스 로더는 클래스를 로드할 수는 있지만 언로드할 수 없다. 현재 클래스 로더를 삭제하고 새로운 클래스 로더 생성은 가능.

### 클래스 로더의 계층 구조

- **BootStrap Class Loader**
    - JVM 시작시 실행.  java.lang package 처럼 JVM 실행에 필요한 클래스 로딩.
    - 다른 클래스 로더와 달리 네이티브 코드로 구현됨
- **Platform Class Loader**
    - java.lang.ClassLoader의 인스턴스로 자바에서 기본적으로 제공하는 클래스(Java SE API 등) 로딩시 사용 → 보안 확장 기능 등 로딩
    - 모듈 시스템 도입되면서 Extension Class Loader에서 명칭 변경
- **System Class Loader**
    - java.lang.ClassLoader의 인스턴스로 유저가 작성한 클래스를 로딩할 때 사용됨
    - 모듈 시스템 도입되면서 Application Class Loader에서 명칭 변경

## 클래스 로더의 수행 과정

![Untitled](https://github.com/9u4a/Study/assets/81855010/8908f102-d8d7-4820-bda5-0af21bc99a28)

자바 애플리케이션의 동작은 로딩,링크,초기화 과정을 거쳐 **최종적으로 특정 클래스의 main함수를 실행하는 것이다**. 해당 과정을 실행하면서 다른 클래스들을 로딩,링크,초기화한다.

### **JVM 실행**

JVM이 시작되면 런타임 데이터 영역이 생성되고 메소드,힙 영역이 할당된다. BootStrap Class Loader는 JVM 실행에 필요한 클래스들을 메소드 영역으로 로딩, System Class Loader를 통해 실행한 클래스를 메소드 영역으로 로딩한다.

### 로딩

클래스 또는 인터페이스의 생성은 해당 클래스의 필드,메소드, 런타임 상수 풀 등 클래스의 바이트코드를 찾은 후 JVM의 메소드 영역에 구성하는 것을 의미. 클래스 로더를 통해 로딩을 진행하며 해당 클래스를 로딩했을 때 클래스의 부모 클래스가 존재할 경우 먼저 부모 클래스를 로딩한다.

### 링크

링크 과정은 로딩된 클래스 파일들에 대해 실제 실행 가능한 바이너리 코드로 변환하는 작업을 수행한다. 검증, 준비, 분석의 3단계로 이루어져 있다.

1. **검증 (Verification)** : 로딩된 클래스의 바이트 코드가 JVM의 명세를 따르고 있는지 검증(보안성, 안전성 요구사항 등)
2. **준비 (Preparation)** : 클래스의 정적 변수들을 메모리에 할당하고 초기화한다.(기본값으로 초기화→ Reference Type은 null)
3. **분석 (Resolution)**: 클래스의 런타임 상수 풀 안에 있는 심볼릭 참조를 실제 메모리 상의 고정된 주소 값으로 바꾸는 과정

검증, 준비, 분석 3가지 과정을 거치면서 다른 클래스의 로딩을 추가적으로 요청할 수 있다. 이 때 분석 과정은 검증, 준비 과정과 같은 시간에 일어날 필요가 없다. 보통 심볼릭 참조를 고정된 주소 값으로 변환시키는 분석 과정은 해당 명령이 실행될 때 일어난다.

### 초기화

초기화 단계에서는 클래스의 정적 변수들과 정적 초기화 블록(static)을 실행한다. 개발자가 명시한 값으로 초기화 되거나, 기본 값으로 초기화 된다. 로딩,검증,준비 과정이 모두 끝났을 때 한번만 실행된다.

### 실행

초기화가 완료된 클래스는 JVM이 실행 엔진에 의해 바이트코드가 해석하며 실행한다. 실행 엔진은 바이트코드를 인터프리터 방식이나 JIT 컴파일러를 사용하여 실행한다. 실행단계에서 메모리, 스레드 관리 등의 작업 수행.

### JVM 종료

일부 스레드가 Runtime 클래스의 종료, 중지 메서드나 클래스 시스템의 종료 메서드를 호출하면 JVM 종료 또는 중지 작업이 Security Managerr에 의해 허용된다.

---
Reference

https://d2.naver.com/helloworld/1230

[https://velog.io/@sgwon1996/JAVA의-동작-원리와-JVM-구조](https://velog.io/@sgwon1996/JAVA%EC%9D%98-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC%EC%99%80-JVM-%EA%B5%AC%EC%A1%B0)

https://coding-factory.tistory.com/828

https://coding-factory.tistory.com/827

https://docs.oracle.com/javase/7/docs/