## 변수와 메소드

### 선언위치에 따른 변수의 종류

변수는 클래스변수, 인스턴스변수, 지역변수 세 종류가 있다.

변수의 종류를 결정짓는 중요한 요소는 변수의 선언된 위치이다.

```java
class Variables{
	int iv; //인스턴스변수
 	static int cv; //클래스변수(static변수, 공유변수)
	
	void method(){
		int lv = 0; //지역변수
	}
}
```

| 변수 종류 | 선언 위치 | 생성시기 |
| --- | --- | --- |
| 클래스 변수 | 클래스 영역 | 클래스가 메모리에 올라갈 때 |
| 인스턴스 변수 | 클래스 영역 | 인스턴스가 생성되었을 때 |
| 지역 변수 | 클래스 영역 이외의 영역 (메소드, 생성자, 초기화 블록 내부) | 변수 선언문이 수행되었을 때 |
- **인스턴스 변수 (instance variable) → Heap**
    - 인스턴스를 생성해야 변수의 값을 읽거나 저장 가능.
    - 독립적인 저장공간을 가지므로 서로 다른 값을 가질 수 있다.
- **클래스 변수 (class variable) → Method Area**
    - 인스턴스 변수 앞에 static을 붙여서 사용
    - **모든 인스턴스가 공통된 저장공간(변수) 공유**
    - 인스턴스를 생성하지 않고도 바로 사용할 수 있다.
        - → ‘클래스이름.클래스변수명’ 의 방식으로 접근
    - 클래스가 메모리에 로딩 될 때 생성되어 프로그램이 종료될 때 까지 유지.
    - public 접근 제어자를 사용하면 전역변수의 성격을 갖는다.
- **지역 변수 (local variable) → Java Stack**
    - 메소드 내에 선언되어 메소드 내에서만 사용 가능.
    - 메소드가 종료되면 소멸

## 메소드

메소드는 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것이다.

**메소드를 사용하는 이유**

- 높은 재사용성
- 중복된 코드의 제거
- 프로그램의 구조화

### 메소드의 선언과 구현

```java
//반환타입 메소드이름 (타입 변수명, ~~){}
int add(int a, int b) //선언부
{
	int result = a + b; //구현부
	return result;
}
```

### 메소드 선언부

메소드 선언부는 메소드의 이름, 매개변수 선언, 반환타입으로 구성되어 있다.

- 매개변수 선언 : 메소드가 작업을 수행할 때 필요한 값들을 제공받기 위한 것.
    - 매개변수도 메소드 내에 선언된 것으로 간주한다 → 지역변수
- 메소드의 이름 : 변수의 명명규칙대로 작성. 동사 위주로 작성하는 경우가 많음
- 반환타입 : 메소드의 작업 수행 결과인 반환값의 타입을 적는다.
- 메소드의 구현부: 메소드의 선언부 다음에 오는 {} 를 구현부라고 하는데 메소드를 호출했을 때 수행될 문장들을 넣는다.
    - return문 : 반환타입이 void가 아닌 경우 return 반환값; 이 반드시 포함되어야 한다.
        - 반환타입과 값이 일치하거나, 자동 형변환이 가능해야 함.
    - 지역변수 : 메소드 내에서 선언된 변수들은 메소드 내에서만 사용 가능.

### 기본형 매개변수와 참조형 매개변수

자바에서는 메소드를 호출할 때 매개변수로 지정한 값을 메소드의 매개변수에 복사해서 넘겨준다.

타입이 기본형일 때는 기본형 값이 복사된다.

타입이 참조형이면 인스턴스의 주소가 복사된다.

**기본형 매개변수 : 변수의 값을 읽기만 할 수 있다.**

**참조형 매개변수 : 변수의 값을 읽고 변경할 수 있다.**

### 참조형 반환타입

반환타입이 참조형이라는 것은 메소드가 객체의 주소를 반환한다는 것을 의미한다.

```java
static Data copy(Data d) {
		Data tmp = new Data();
		tmp.x = d.x;
		return tmp;
}

Data d2 = copy(d); 
```

→ 메소드 내에서 생성한 객체를 메소드 밖에서 사용하기 위하여 객체의 주소를 참조변수에 저장

### 재귀호출

메소드의 내부에서 메소드 자신을 다시 호출하는 것.

```java
void method() {
		method();
}
```

호출된 메소드는 **값에 의한 호출(call by value)**를 통해, 원래의 값이 아닌 복사된 값으로 작업하기 때문에 호출한 메소드와 관계없이 독립적인 작업수행이 가능하다.

**재귀호출을 사용하는 이유 :** 몇 겹의 반복문과 조건문으로 복잡하게 작성된 코드를 재귀호출을 통해 단순한 구조로 바꿀 수 있어서

### 클래스 메소드와 인스턴스 메소드

변수와 마찬가지로 메소드 앞에 static이 붙으면 클래스 메소드이고 붙어 있지 않으면 인스턴스 메소드이다. 클래스를 정의할 때 **어느 경우에 static을 사용해서 클래스 메소드로 정의해야 할까?**

인스턴스 메소드는 메소드의 작업을 수행하는데 인스턴스 변수를 필요로 하는 메소드이다.

→ 인스턴스 변수는 인스턴스를 생성해야만 만들어지므로 인스턴스 메소드 역시 생성해야 호출할 수 있다.

클래스 메소드는 인스턴스와 관계없는 메소드를 클래스 메소드로 정의한다.

- 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.
- 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있다.
    - static이 붙은 변수는 클래스가 메모리에 올라갈 때 자동적으로 생성되기 때문
- 클래스 메소드는 인스턴스 변수를 사용할 수 없다.
    - 클래스 메소드가 호출되었을 때 인스턴스가 존재하지 않을 수도 있어서 사용x
- 메소드 내에서 인스턴스 변수를 사용하지 않는다면 static을 붙이는 것을 고려한다.
    - 메소드 호출시간이 짧아지므로 성능 향상

### **클래스 멤버와 인스턴스 멤버간의 참조와 호출**

같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출이 가능하다. 단, 클래스 멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야 한다.

→ **인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 클래스 멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있기 때문**

```java
class MemberClass {
		int iv; //인스턴스 변수
		static int cv; //클래스 변수
		void instanceMethod() {} //인스턴스 메소드
		static void staticMethod() {} //클래스 메소드
		static int cv2 = iv; //클래스 변수는 인스턴스 변수를 사용할 수 없음.
		static int cv3 = new MemberClass().iv; //인스턴스 생성해야 사용가능.
		
		void instanceMethod2() {
				System.out.println(iv);
				System.out.println(cv);
				instanceMehtod();
				staticMethod();
		}
		
		static void staticMethod2() {
				System.out.println(iv); //인스턴스 변수를 사용할 수 없음.
				System.out.println(cv);
				instanceMethod(); //인스턴스 메소드를 호출할 수 없음.
				staticMethod();
				MemberClass m = new MemberClass();
				System.out.println(m.iv); //인스턴스 생성한 후 인스턴스 변수 참조가능.
		}
}
```

### 오버로딩

한 클래스 내에 같은 이름의 메소드를 여러 개 정의하는 것을 메소드 오버로딩이라고 한다.

**오버로딩의 조건**

- 메소드 이름이 같아야 한다.
- 매개변수의 개수 또는 타입이 달라야 한다.

→ 서로 다른 **시그니처**를 갖는 여러 메소드를 같은 이름으로 정의하는 것.

**메소드 시그니처 :** 메소드의 선언부에 명시되는 매개변수의 리스트

### 오버로딩의 예

가장 대표적인 예로는 println() 메소드를 들 수 있다.

- println()
- println(**boolean** x)
- println(**char** x)
- println(**char**[] x)
- println(**double** x)
- println(**float** x)
- println(**int** x)
- println(**long** x)
- println(**Object** x)
- println(**String** x)

println 메소드를 호출할 때  매개변수로 넘겨주는 값의 타입에 따라서 오버로딩된 메소드들 중의 하나가 실행되는 것이다.

**오버로딩의 장점**

근본적으로 같은 기능을 하는 메소드들을 오버로딩하지 않고 사용한다면 서로 다른 이름을 가져야하기에 비효율적이다.

→ 오버로딩을 통해 하나의 이름으로 정의될 수 있다면 더 편리.

### 가변인자와 오버로딩

기존에는 메소드의 매개변수 개수가 고정적이었으나 jdk1.5부터 동적으로 지정해 줄 수 있다.

→ 가변인자 (varargs)

```java
//PrintStream 클래스의 printf()
//타입... 변수명 의 형태로 선언한다.
public PrintStream printf(String format, Object... args) {...}
```

가변인자 외에도 매개변수가 존재할 경우 가변인자를 매개변수 중에서 제일 마지막에 선언해야 한다.

```java
String varargTest(String... str) {...}

System.out.println(varargTest("a"));
System.out.println(varargTest("a","b"));
System.out.println(varargTest(new String[]{"A","B"})); //배열도 가능
```

가변인자가 선언된 메소드를 호출할 때마다 배열이 새로 생성된다.

→ 편리하지만 효율적이지 않다.

매개변수의 타입을 배열로 하는 것과 가변인자는 무슨 차이가 있는가?

→ 매개변수의 타입을 배열로 하면 반드시 인자를 지정해 줘야 함 (NULL이나 길이가 0인 배열)

**가변인자를 선언한 메소드를 오버로딩하면 메소드를 호출했을 때 구별되지 못하는 경우가 발생할 수 있다. 가능하면 가변인자를 사용한 메소드는 오버로딩하지 않는 것이 좋다.**

---

Reference