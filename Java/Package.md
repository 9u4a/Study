## 패키지 (Package)

패키지는 클래스의 묶음이다. 서로 관련된 클래스들을 그룹 단위로 묶어 효율적으로 관리할 수 있다.

- 하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용
- 모든 클래스는 반드시 하나의 패키지에 속해야 한다.
- 패키지는 점 ( . ) 을 구분자로 하여 계층구조로 구성할 수 있다.
- 패키지는 물리적으로 클래스 파일을 포함하는 하나의 디렉터리다.

### 패키지의 선언

```java
package 패키지명;
```

### 클래스패스( CLASSPATH )

소스 코드를 컴파일하면 바이트 코드로 변환되는데 바이트 코드를 실행하기 위하여 파일을 찾아야 한다. 

→ **클래스패스**는 컴파일러나 JVM 등이 클래스의 위치를 찾는데 사용되는 경로이다.

**클래스패스 지정하는 방법**

- CLASSPATH 환경변수 사용
    - JVM의 클래스로더가 런타임 시에 환경변수를 호출해 해당 경로에 정의된 클래스들을 로딩
- classpath옵션 사용
    - ex) java -cp c:\jdk\workspace
    

## import

매번 다른 패키지의 클래스를 사용하려면 패키지명이 포함된 클래스 이름을 사용해야 한다.

→ Import문을 사용하여 클래스의 패키지를 명시해 패키지명을 생략할 수 있다.

컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공한다.

### import의 선언

모든 소스파일에서 package문 다음에, 클래스 선언문 이전에 위치해야 한다.

```java
import 패키지명.클래스명;
import 패키지명.*;
```

패키지명.* 을 사용하면 패키지에 속하는 모든 클래스를 패키지명 없이 사용 가능.

→ 컴파일 시간이 조금 늘어나지만, 실행 시 성능상의 차이 x

### static import

static멤버를 호출할 때 클래스 이름을 생략할 수 있는 import문

jdk1.5부터 지원.

### static import의 선언

```java
import static java.lang.System.out;

out.println("~~~~");
```

## 제어자 (Modifier)

제어자는 클래스, 변수, 메소드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.

종류는 크게 접근 제어자와 그 외의 제어자로 나눌 수 있다.

- 접근 제어자 : public, protected, default, private
- 그 외 : static, fiinal, abstract, native, transient, synchronized, volatile, strictfp

하나의 대상에 대해서 여러 제어자를 조합하여 사용하는 것이 가능하다.

단, 접근 제어자는 하나만 선택해서 사용가능.

### final

final을 사용하면 변수는 변경할 수 없는 상수가 되고, 메소드에 사용하면 오버라이딩을 할 수 없게 된다. 클래스에 사용하면 자신을 확장하는 자손클래스를 정의하지 못하게 된다.

final이 붙은 인스턴스 변수의 경우 생성자에서 초기화 되도록 할 수 있다.

→ 각 인스턴스마다 다른 값을 가지는 상수 생성가능.

```java
class Card {
	final int NUMBER;

	Card(int num){
		NUMBER = num;
	}
}
```

### 접근 제어자

접근 제어자는 멤버 또는 클래스에 사용되어 외부에서 접근하지 못하도록 제한하는 역할을 한다.

접근 제어자가 명시되어 있지 않다면 default

**접근 제어자를 사용하는 이유** 

- 외부로부터 데이터를 보호하기 위해
- 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서

**접근 제어자가 사용될 수 있는 곳 : 클래스, 멤버변수, 메소드, 생성자**

- private : 같은 클래스 내에서만 접근이 가능하다.
- protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근이 가능하다.
- default : 같은 패키지 내에서만 접근이 가능하다.
- public : 접근 제한이 없다.

**제어자의 조합**

- 메소드에 static과 abstract를 함께 사용할 수 없다.
- 클래스에 abstract와 final을 동시에 사용할 수 없다.
- abstract메소드의 접근 제어자가 private일 수 없다.
- 메소드에 private과 final을 같이 사용할 필요는 없다.

---

Reference